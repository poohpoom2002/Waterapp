/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */

export interface Coordinate {
    lat: number;
    lng: number;
}

// üöÄ Caching mechanism for plant grouping
interface PlantGroupCache {
    plantsHash: string;
    rowGroups: PlantLocation[][];
    columnGroups: PlantLocation[][];
}

let plantGroupCache: PlantGroupCache | null = null;

// üöÄ Helper function to create hash from plants array for caching
const createPlantsHash = (plants: PlantLocation[]): string => {
    return plants
        .map(plant => `${plant.id}:${plant.position.lat.toFixed(8)}:${plant.position.lng.toFixed(8)}:${plant.rotationAngle || 0}`)
        .join('|');
};

// üöÄ Clear plant grouping cache - useful when plants array structure changes significantly
export const clearPlantGroupingCache = (): void => {
    plantGroupCache = null;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á 2 ‡πÄ‡∏™‡πâ‡∏ô
export const findLineIntersection = (
    line1Start: Coordinate,
    line1End: Coordinate,
    line2Start: Coordinate,
    line2End: Coordinate
): Coordinate | null => {
    const x1 = line1Start.lng, y1 = line1Start.lat;
    const x2 = line1End.lng, y2 = line1End.lat;
    const x3 = line2Start.lng, y3 = line2Start.lat;
    const x4 = line2End.lng, y4 = line2End.lat;

    const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    
    if (Math.abs(denominator) < 1e-10) {
        return null; // ‡πÄ‡∏™‡πâ‡∏ô‡∏Ç‡∏∂‡πâ‡∏á‡∏Ç‡∏ô‡∏≤‡∏ô‡∏Å‡∏±‡∏ô
    }

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

    if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
        // ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô
        return {
            lat: y1 + t * (y2 - y1),
            lng: x1 + t * (x2 - x1)
        };
    }

    return null; // ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
export const findLateralSubMainIntersection = (
    lateralStart: Coordinate,
    lateralEnd: Coordinate,
    subMainPipes: SubMainPipe[]
): {
    intersectionPoint: Coordinate;
    subMainPipeId: string;
    segmentIndex: number;
} | null => {
    for (const subMainPipe of subMainPipes) {
        if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
            continue;
        }

        for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
            const segmentStart = subMainPipe.coordinates[i];
            const segmentEnd = subMainPipe.coordinates[i + 1];

            const intersection = findLineIntersection(
                lateralStart,
                lateralEnd,
                segmentStart,
                segmentEnd
            );

            if (intersection) {
                return {
                    intersectionPoint: intersection,
                    subMainPipeId: subMainPipe.id,
                    segmentIndex: i
                };
            }
        }
    }

    return null;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á (‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏•‡∏≤‡∏Å‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á)
export const findLateralToSubMainIntersections = (
    lateralPipes: any[],
    subMainPipes: any[],
    zones?: any[],
    irrigationZones?: any[],
    snapThreshold: number = 10
): {
    lateralPipeId: string;
    subMainPipeId: string;
    intersectionPoint: Coordinate;
    segmentIndex: number;
}[] => {
    const intersections: {
        lateralPipeId: string;
        subMainPipeId: string;
        intersectionPoint: Coordinate;
        segmentIndex: number;
    }[] = [];
    
    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠
    const findPipeZone = (pipe: any): string | null => {
        if (!pipe.coordinates || pipe.coordinates.length === 0) return null;
        
        const endPoint = pipe.coordinates[pipe.coordinates.length - 1];
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        return null;
    };

    for (const lateralPipe of lateralPipes) {
        if (!lateralPipe.coordinates || lateralPipe.coordinates.length < 2) {
            continue;
        }

        const lateralZone = findPipeZone(lateralPipe);

        for (const subMainPipe of subMainPipes) {
            if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
                continue;
            }

            const subMainZone = findPipeZone(subMainPipe);
            
            // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
            if (lateralZone && subMainZone && lateralZone !== subMainZone) {
                continue;
            }

            // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
            for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
                const segmentStart = subMainPipe.coordinates[i];
                const segmentEnd = subMainPipe.coordinates[i + 1];

                const intersection = findLineIntersection(
                    lateralPipe.coordinates[0],
                    lateralPipe.coordinates[lateralPipe.coordinates.length - 1],
                    segmentStart,
                    segmentEnd
                );

                if (intersection) {
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô threshold
                    const distanceToStart = calculateDistanceBetweenPoints(intersection, lateralPipe.coordinates[0]);
                    const distanceToEnd = calculateDistanceBetweenPoints(intersection, lateralPipe.coordinates[lateralPipe.coordinates.length - 1]);
                    const lateralLength = calculateDistanceBetweenPoints(lateralPipe.coordinates[0], lateralPipe.coordinates[lateralPipe.coordinates.length - 1]);
                    
                    // üî• ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏≠‡∏¢‡∏π‡πà "‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á" ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
                    // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î (‡∏ã‡∏∂‡πà‡∏á‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô connection ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà intersection)
                    const isAtStart = distanceToStart < 5; // ‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏°‡∏≤‡∏Å (5 ‡πÄ‡∏°‡∏ï‡∏£)
                    const isAtEnd = distanceToEnd < 5; // ‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏°‡∏≤‡∏Å (5 ‡πÄ‡∏°‡∏ï‡∏£)
                    const isInMiddle = distanceToStart > 5 && distanceToEnd > 5 && 
                                     distanceToStart < lateralLength - 5 && 
                                     distanceToEnd < lateralLength - 5;
                    
                    // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô intersection
                    if (isInMiddle) {
                        intersections.push({
                            lateralPipeId: lateralPipe.id,
                            subMainPipeId: subMainPipe.id,
                            intersectionPoint: {
                                lat: parseFloat(intersection.lat.toFixed(8)),
                                lng: parseFloat(intersection.lng.toFixed(8))
                            },
                            segmentIndex: i
                        });
                    }
                }
            }
        }
    }

    return intersections;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏¢‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢
export const calculateLateralPipeSegmentStats = (
    lateralStart: Coordinate,
    lateralEnd: Coordinate,
    intersectionPoint: Coordinate,
    plants: PlantLocation[]
): {
    segment1: {
        length: number;
        plants: PlantLocation[];
        waterNeed: number;
    };
    segment2: {
        length: number;
        plants: PlantLocation[];
        waterNeed: number;
    };
    total: {
        length: number;
        plants: PlantLocation[];
        waterNeed: number;
    };
} => {
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡πà‡∏ß‡∏ô
    const segment1Length = calculateDistanceBetweenPoints(lateralStart, intersectionPoint);
    const segment2Length = calculateDistanceBetweenPoints(intersectionPoint, lateralEnd);
    const totalLength = calculateDistanceBetweenPoints(lateralStart, lateralEnd);

    // ‡πÅ‡∏ö‡πà‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏™‡πà‡∏ß‡∏ô - ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°
    const segment1Plants: PlantLocation[] = [];
    const segment2Plants: PlantLocation[] = [];

    const distanceFromStartToIntersection = segment1Length;
    const totalDistance = totalLength;

    plants.forEach(plant => {
        // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ô‡∏µ‡πâ
        const closestPoint = findClosestPointOnLineSegment(plant.position, lateralStart, lateralEnd);
        const distanceFromStart = calculateDistanceBetweenPoints(lateralStart, closestPoint);
        
        // ‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ñ‡∏∂‡∏á‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î
        // ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡πÅ‡∏£‡∏Å
        if (distanceFromStart <= distanceFromStartToIntersection + 1) { // +1 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô
            segment1Plants.push(plant);
        } else {
            segment2Plants.push(plant);
        }
    });

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡πâ‡∏≥
    const segment1WaterNeed = segment1Plants.reduce((sum, plant) => sum + plant.plantData.waterNeed, 0);
    const segment2WaterNeed = segment2Plants.reduce((sum, plant) => sum + plant.plantData.waterNeed, 0);
    const totalWaterNeed = segment1WaterNeed + segment2WaterNeed;

    return {
        segment1: {
            length: segment1Length,
            plants: segment1Plants,
            waterNeed: segment1WaterNeed
        },
        segment2: {
            length: segment2Length,
            plants: segment2Plants,
            waterNeed: segment2WaterNeed
        },
        total: {
            length: totalLength,
            plants: plants,
            waterNeed: totalWaterNeed
        }
    };
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡πÅ‡∏•‡∏∞‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
// üéØ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡∏î‡πâ‡∏ß‡∏¢ - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
export const findMainToSubMainConnections = (
    mainPipes: any[],
    subMainPipes: any[],
    zones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° zones parameter
    irrigationZones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° irrigationZones parameter
    snapThreshold: number = 10
): {
    mainPipeId: string;
    subMainPipeId: string;
    connectionPoint: Coordinate;
}[] => {
    const connections: {
        mainPipeId: string;
        subMainPipeId: string;
        connectionPoint: Coordinate;
    }[] = [];

    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠ (‡∏ï‡∏≤‡∏°‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢)
    const findPipeZone = (pipe: any): string | null => {
        if (!pipe.coordinates || pipe.coordinates.length === 0) return null;
        
        const endPoint = pipe.coordinates[pipe.coordinates.length - 1];
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        return null;
    };

    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÇ‡∏ã‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const checkMainPipePassesThroughMultipleZones = (mainPipe: any): boolean => {
        if (!mainPipe.coordinates || mainPipe.coordinates.length < 2) return false;
        
        const zonesFound = new Set<string>();
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î‡πÉ‡∏ô‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô
        for (const point of mainPipe.coordinates) {
            // ‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏à‡∏∏‡∏î‡∏ô‡∏µ‡πâ
            if (irrigationZones) {
                for (const zone of irrigationZones) {
                    if (isPointInPolygon(point, zone.coordinates)) {
                        zonesFound.add(zone.id);
                        break;
                    }
                }
            }
            if (zonesFound.size === 0 && zones) {
                for (const zone of zones) {
                    if (isPointInPolygon(point, zone.coordinates)) {
                        zonesFound.add(zone.id);
                        break;
                    }
                }
            }
        }
        
        // ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 1 ‡πÇ‡∏ã‡∏ô ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÇ‡∏ã‡∏ô
        return zonesFound.size > 1;
    };

    for (const mainPipe of mainPipes) {
        if (!mainPipe.coordinates || mainPipe.coordinates.length < 2) {
            continue;
        }

        // ‡∏î‡∏π‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á main pipe
        const mainEnd = mainPipe.coordinates[mainPipe.coordinates.length - 1];
        const mainZone = findPipeZone(mainPipe);

        for (const subMainPipe of subMainPipes) {
            if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
                continue;
            }

            // ‡∏î‡∏π‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ç‡∏≠‡∏á submain pipe
            const subMainStart = subMainPipe.coordinates[0];
            const subMainZone = findPipeZone(subMainPipe);
            
            const distance = calculateDistanceBetweenPoints(mainEnd, subMainStart);
            
            // üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
            if (mainZone && subMainZone && mainZone !== subMainZone) {
                // üö® ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô: ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÇ‡∏ã‡∏ô‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                const isMultiZoneMainPipe = checkMainPipePassesThroughMultipleZones(mainPipe);
                
                if (!isMultiZoneMainPipe) {
                    continue; // ‡∏Ç‡πâ‡∏≤‡∏° - ‡∏ï‡πà‡∏≤‡∏á‡πÇ‡∏ã‡∏ô‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ó‡πà‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡πÇ‡∏ã‡∏ô
                }
            }
            
            if (distance <= snapThreshold) {
                // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏à‡∏£‡∏¥‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
                let connectionPoint: Coordinate;
                let actualIntersection: Coordinate | null = null;
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏∏‡∏Å segment ‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
                for (let i = 0; i < mainPipe.coordinates.length - 1; i++) {
                    const mainSegStart = mainPipe.coordinates[i];
                    const mainSegEnd = mainPipe.coordinates[i + 1];
                    
                    for (let j = 0; j < subMainPipe.coordinates.length - 1; j++) {
                        const subMainSegStart = subMainPipe.coordinates[j];
                        const subMainSegEnd = subMainPipe.coordinates[j + 1];
                        
                        const intersection = findLineIntersection(
                            mainSegStart,
                            mainSegEnd,
                            subMainSegStart,
                            subMainSegEnd
                        );
                        
                        if (intersection) {
                            actualIntersection = intersection;
                            break;
                        }
                    }
                    if (actualIntersection) break;
                }
                
                if (actualIntersection) {
                    // ‡πÉ‡∏ä‡πâ‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏à‡∏£‡∏¥‡∏á
                    connectionPoint = {
                        lat: parseFloat(actualIntersection.lat.toFixed(8)),
                        lng: parseFloat(actualIntersection.lng.toFixed(8))
                    };
                } else {
                    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î ‡πÉ‡∏ä‡πâ‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
                    connectionPoint = {
                        lat: (mainEnd.lat + subMainStart.lat) / 2,
                        lng: (mainEnd.lng + subMainStart.lng) / 2
                    };
                }

                connections.push({
                    mainPipeId: mainPipe.id,
                    subMainPipeId: subMainPipe.id,
                    connectionPoint: connectionPoint
                });
                continue; // ‡∏´‡∏≤‡πÄ‡∏à‡∏≠‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á
            }
            
            // üî• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏Å‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
            for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
                const segmentStart = subMainPipe.coordinates[i];
                const segmentEnd = subMainPipe.coordinates[i + 1];
                
                // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô segment ‡∏ô‡∏µ‡πâ
                const closestPoint = findClosestPointOnLineSegment(mainEnd, segmentStart, segmentEnd);
                const distanceToSegment = calculateDistanceBetweenPoints(mainEnd, closestPoint);
                
                if (distanceToSegment <= snapThreshold) {
                    connections.push({
                        mainPipeId: mainPipe.id,
                        subMainPipeId: subMainPipe.id,
                        connectionPoint: {
                            lat: parseFloat(closestPoint.lat.toFixed(8)),
                            lng: parseFloat(closestPoint.lng.toFixed(8))
                        }
                    });
                    break; // ‡∏´‡∏≤‡πÄ‡∏à‡∏≠‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö segment ‡∏≠‡∏∑‡πà‡∏ô
                }
            }
        }
    }

    return connections;
};

// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏•‡∏≤‡∏¢‡πÇ‡∏ã‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
const checkMainPipePassesThroughMultipleZones = (
    mainPipe: any,
    zones?: any[],
    irrigationZones?: any[]
): boolean => {
    if (!mainPipe.coordinates || mainPipe.coordinates.length < 2) return false;
    
    const zonesFound = new Set<string>();
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å‡∏à‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô
    for (const point of mainPipe.coordinates) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(point, zone.coordinates)) {
                    zonesFound.add(zone.id);
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(point, zone.coordinates)) {
                    zonesFound.add(zone.id);
                }
            }
        }
    }
    
    
    // ‡∏ñ‡πâ‡∏≤‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ 1 ‡πÇ‡∏ã‡∏ô ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡πà‡∏≠‡∏Ç‡πâ‡∏≤‡∏°‡πÇ‡∏ã‡∏ô
    return zonesFound.size > 1;
};

// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà
const findZoneAtPoint = (point: Coordinate, zones?: any[], irrigationZones?: any[]): string | null => {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
    if (irrigationZones) {
        for (const zone of irrigationZones) {
            if (isPointInPolygon(point, zone.coordinates)) {
                return zone.id;
            }
        }
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
    if (zones) {
        for (const zone of zones) {
            if (isPointInPolygon(point, zone.coordinates)) {
                return zone.id;
            }
        }
    }
    
    return null;
};

// Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
const isPointInPolygon = (point: Coordinate, polygon: Coordinate[]): boolean => {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        if (((polygon[i].lat > point.lat) !== (polygon[j].lat > point.lat)) &&
            (point.lng < (polygon[j].lng - polygon[i].lng) * (point.lat - polygon[i].lat) / (polygon[j].lat - polygon[i].lat) + polygon[i].lng)) {
            inside = !inside;
        }
    }
    return inside;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢ (‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô)
// üéØ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡∏î‡πâ‡∏ß‡∏¢ - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
export const findSubMainToLateralStartConnections = (
    subMainPipes: any[],
    lateralPipes: any[],
    zones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° zones parameter
    irrigationZones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° irrigationZones parameter
    snapThreshold: number = 10
): {
    subMainPipeId: string;
    lateralPipeId: string;
    connectionPoint: Coordinate;
}[] => {
    const connections: {
        subMainPipeId: string;
        lateralPipeId: string;
        connectionPoint: Coordinate;
    }[] = [];
    
    // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏° Set ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ã‡πâ‡∏≥
    const connectionKeys = new Set<string>();

    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠ (‡∏ï‡∏≤‡∏°‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢)
    const findPipeZone = (pipe: any): string | null => {
        if (!pipe.coordinates || pipe.coordinates.length === 0) return null;
        
        const endPoint = pipe.coordinates[pipe.coordinates.length - 1];
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        return null;
    };

    for (const lateralPipe of lateralPipes) {
        if (!lateralPipe.coordinates || lateralPipe.coordinates.length < 2) {
            continue;
        }

        const lateralStart = lateralPipe.coordinates[0];
        const lateralZone = findPipeZone(lateralPipe);

        for (const subMainPipe of subMainPipes) {
            if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
                continue;
            }

            const subMainZone = findPipeZone(subMainPipe);
            
            // üî• ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
            if (lateralZone && subMainZone && lateralZone !== subMainZone) {
                continue; // ‡∏Ç‡πâ‡∏≤‡∏° - ‡∏ï‡πà‡∏≤‡∏á‡πÇ‡∏ã‡∏ô‡∏Å‡∏±‡∏ô
            }

            // üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏à‡∏£‡∏¥‡∏á‡πÜ
            const closestPoint = findClosestConnectionPoint(lateralStart, subMainPipe);
            
            if (closestPoint) {
                const distance = calculateDistanceBetweenPoints(lateralStart, closestPoint);

                if (distance <= snapThreshold) {
                    // üî• ‡∏•‡∏î‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô - ‡∏ñ‡πâ‡∏≤‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏°‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡∏ñ‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô connection
                    // ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏ó‡πà‡∏≠‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏û‡∏•‡∏≤‡∏î‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                    
                    // üî• ‡∏™‡∏£‡πâ‡∏≤‡∏á unique key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
                    const connectionKey = `${subMainPipe.id}-${lateralPipe.id}`;
                    
                    if (!connectionKeys.has(connectionKey)) {
                        connectionKeys.add(connectionKey);
                        connections.push({
                            subMainPipeId: subMainPipe.id,
                            lateralPipeId: lateralPipe.id,
                            connectionPoint: {
                                lat: parseFloat(closestPoint.lat.toFixed(8)),
                                lng: parseFloat(closestPoint.lng.toFixed(8))
                            }
                        });
                    }
                } else {
                    console.log(`‚ùå Rejected lateral-submain connection: distance ${distance.toFixed(2)}m > threshold ${snapThreshold}m`);
                }
            }
        }
    }

    return connections;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô (‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏•‡∏≤‡∏Å‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô)
// üéØ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡∏î‡πâ‡∏ß‡∏¢ - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
export const findSubMainToMainIntersections = (
    subMainPipes: any[],
    mainPipes: any[],
    zones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° zones parameter  
    irrigationZones?: any[] // ‡πÄ‡∏û‡∏¥‡πà‡∏° irrigationZones parameter
): {
    subMainPipeId: string;
    mainPipeId: string;
    intersectionPoint: Coordinate;
    subMainSegmentIndex: number;
    mainSegmentIndex: number;
}[] => {
    const intersections: {
        subMainPipeId: string;
        mainPipeId: string;
        intersectionPoint: Coordinate;
        subMainSegmentIndex: number;
        mainSegmentIndex: number;
    }[] = [];
    
    // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏° Set ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏ã‡πâ‡∏≥
    const intersectionKeys = new Set<string>();

    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠ (‡∏ï‡∏≤‡∏°‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢)
    const findPipeZone = (pipe: any): string | null => {
        if (!pipe.coordinates || pipe.coordinates.length === 0) return null;
        
        const endPoint = pipe.coordinates[pipe.coordinates.length - 1];
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        return null;
    };

    for (const subMainPipe of subMainPipes) {
        if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
            continue;
        }

        const subMainZone = findPipeZone(subMainPipe);

        for (const mainPipe of mainPipes) {
            if (!mainPipe.coordinates || mainPipe.coordinates.length < 2) {
                continue;
            }

            const mainZone = findPipeZone(mainPipe);
            
            // üî• ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô: ‡∏´‡πâ‡∏≤‡∏°‡∏ó‡πà‡∏≠‡∏Ñ‡∏ô‡∏•‡∏∞‡πÇ‡∏ã‡∏ô‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô
            if (subMainZone && mainZone && subMainZone !== mainZone) {
                continue; // ‡∏Ç‡πâ‡∏≤‡∏° - ‡∏ó‡πà‡∏≠‡∏Ñ‡∏ô‡∏•‡∏∞‡πÇ‡∏ã‡∏ô‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô
            }
            
            // üî• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°: ‡∏ñ‡πâ‡∏≤‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
            // ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏ô‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô connection (‡∏™‡∏µ‡πÅ‡∏î‡∏á) ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà intersection (‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô)
            const subMainStart = subMainPipe.coordinates[0];
            const subMainEnd = subMainPipe.coordinates[subMainPipe.coordinates.length - 1];
            const mainStart = mainPipe.coordinates[0];
            const mainEnd = mainPipe.coordinates[mainPipe.coordinates.length - 1];
            
            const distanceToMainStart = calculateDistanceBetweenPoints(subMainStart, mainStart);
            const distanceToMainEnd = calculateDistanceBetweenPoints(subMainStart, mainEnd);
            const distanceToMainStartFromEnd = calculateDistanceBetweenPoints(subMainEnd, mainStart);
            const distanceToMainEndFromEnd = calculateDistanceBetweenPoints(subMainEnd, mainEnd);
            
            // ‡∏ñ‡πâ‡∏≤‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢ (‡πÉ‡∏Å‡∏•‡πâ‡∏°‡∏≤‡∏Å) ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°
            if (distanceToMainStart < 20 || distanceToMainEnd < 20 || 
                distanceToMainStartFromEnd < 20 || distanceToMainEndFromEnd < 20) {
                continue; // ‡∏Ç‡πâ‡∏≤‡∏° - ‡∏ô‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô connection ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà intersection
            }

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏±‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ segment
            for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
                const subMainStart = subMainPipe.coordinates[i];
                const subMainEnd = subMainPipe.coordinates[i + 1];

                for (let j = 0; j < mainPipe.coordinates.length - 1; j++) {
                    const mainStart = mainPipe.coordinates[j];
                    const mainEnd = mainPipe.coordinates[j + 1];

                    const intersection = findLineIntersection(
                        subMainStart,
                        subMainEnd,
                        mainStart,
                        mainEnd
                    );

                    if (intersection) {
                        // üî• ‡∏™‡∏£‡πâ‡∏≤‡∏á unique key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
                        const intersectionKey = `${subMainPipe.id}-${mainPipe.id}-${i}-${j}`;
                        
                        if (!intersectionKeys.has(intersectionKey)) {
                            intersectionKeys.add(intersectionKey);
                            intersections.push({
                                subMainPipeId: subMainPipe.id,
                                mainPipeId: mainPipe.id,
                                intersectionPoint: intersection,
                                subMainSegmentIndex: i,
                                mainSegmentIndex: j
                            });
                        }
                    }
                }
            }
        }
    }

    return intersections;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡πà‡∏≠ (mid-connections) - ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ó‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏ó‡πà‡∏≠‡∏´‡∏ô‡∏∂‡πà‡∏á
// üéØ ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡∏î‡πâ‡∏ß‡∏¢ - ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ã‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô
export const findMidConnections = (
    sourcePipes: any[],
    targetPipes: any[],
    snapThreshold: number = 10,
    zones?: any[], // ‡πÄ‡∏û‡∏¥‡πà‡∏° zones parameter
    irrigationZones?: any[] // ‡πÄ‡∏û‡∏¥‡πà‡∏° irrigationZones parameter
): {
    sourcePipeId: string;
    targetPipeId: string;
    connectionPoint: Coordinate;
    sourceEndIndex: number; // 0 = start, length-1 = end
    targetSegmentIndex: number;
}[] => {
    const connections: {
        sourcePipeId: string;
        targetPipeId: string;
        connectionPoint: Coordinate;
        sourceEndIndex: number;
        targetSegmentIndex: number;
    }[] = [];
    
    // üî• ‡πÄ‡∏û‡∏¥‡πà‡∏° Set ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ã‡πâ‡∏≥
    const connectionKeys = new Set<string>();

    // Helper function ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏´‡∏≤‡πÇ‡∏ã‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠ (‡∏ï‡∏≤‡∏°‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢)
    const findPipeZone = (pipe: any): string | null => {
        if (!pipe.coordinates || pipe.coordinates.length === 0) return null;
        
        const endPoint = pipe.coordinates[pipe.coordinates.length - 1];
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô irrigationZones ‡∏Å‡πà‡∏≠‡∏ô
        if (irrigationZones) {
            for (const zone of irrigationZones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô zones ‡∏£‡∏≠‡∏á
        if (zones) {
            for (const zone of zones) {
                if (isPointInPolygon(endPoint, zone.coordinates)) {
                    return zone.id;
                }
            }
        }
        
        return null;
    };

    for (const sourcePipe of sourcePipes) {
        if (!sourcePipe.coordinates || sourcePipe.coordinates.length < 2) {
            continue;
        }

        const sourceZone = findPipeZone(sourcePipe);

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á source pipe
        const endpoints = [
            { point: sourcePipe.coordinates[0], index: 0 },
            { point: sourcePipe.coordinates[sourcePipe.coordinates.length - 1], index: sourcePipe.coordinates.length - 1 }
        ];

        for (const endpoint of endpoints) {
            for (const targetPipe of targetPipes) {
                if (!targetPipe.coordinates || targetPipe.coordinates.length < 2 || targetPipe.id === sourcePipe.id) {
                    continue;
                }

                const targetZone = findPipeZone(targetPipe);
                
                // üî• ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ã‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á: ‡∏´‡πâ‡∏≤‡∏°‡∏ó‡πà‡∏≠‡∏Ñ‡∏ô‡∏•‡∏∞‡πÇ‡∏ã‡∏ô‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ô
                if (sourceZone && targetZone && sourceZone !== targetZone) {
                    continue; // ‡∏Ç‡πâ‡∏≤‡∏° - ‡∏ó‡πà‡∏≠‡∏Ñ‡∏ô‡∏•‡∏∞‡πÇ‡∏ã‡∏ô‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ô
                }

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏õ‡∏•‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á source pipe ‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô target pipe ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                for (let i = 0; i < targetPipe.coordinates.length - 1; i++) {
                    const segmentStart = targetPipe.coordinates[i];
                    const segmentEnd = targetPipe.coordinates[i + 1];

                    const closestPoint = findClosestPointOnLineSegment(endpoint.point, segmentStart, segmentEnd);
                    const distance = calculateDistanceBetweenPoints(endpoint.point, closestPoint);

                    if (distance <= snapThreshold) {
                        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏õ‡∏•‡∏≤‡∏¢‡∏ï‡πà‡∏≠‡∏õ‡∏•‡∏≤‡∏¢ (end-to-end connection)
                        const isEndToEndConnection = 
                            (calculateDistanceBetweenPoints(endpoint.point, segmentStart) <= snapThreshold) ||
                            (calculateDistanceBetweenPoints(endpoint.point, segmentEnd) <= snapThreshold);

                        if (!isEndToEndConnection) {
                            // üî• ‡∏™‡∏£‡πâ‡∏≤‡∏á unique key ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô
                            const connectionKey = `${sourcePipe.id}-${targetPipe.id}-${endpoint.index}-${i}`;
                            
                            if (!connectionKeys.has(connectionKey)) {
                                connectionKeys.add(connectionKey);
                                connections.push({
                                    sourcePipeId: sourcePipe.id,
                                    targetPipeId: targetPipe.id,
                                    connectionPoint: closestPoint,
                                    sourceEndIndex: endpoint.index,
                                    targetSegmentIndex: i
                                });
                            }
                        }
                    }
                }
            }
        }
    }

    return connections;
};

export interface PlantLocation {
    id: string;
    position: Coordinate;
    plantData: {
        id: number;
        name: string;
        plantSpacing: number;
        rowSpacing: number;
        waterNeed: number;
    };
    rotationAngle?: number;
}

export interface SubMainPipe {
    id: string;
    coordinates: Coordinate[];
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Å‡∏ß‡πà‡∏≤
export const calculateDistanceBetweenPoints = (point1: Coordinate, point2: Coordinate): number => {
    // ‡πÉ‡∏ä‡πâ haversine formula ‡∏ó‡∏µ‡πà‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡πÜ
    const R = 6371000; // Earth's radius in meters
    const dLat = (point2.lat - point1.lat) * Math.PI / 180;
    const dLng = (point2.lng - point1.lng) * Math.PI / 180;
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Å‡∏ß‡πà‡∏≤
    const lat1Rad = point1.lat * Math.PI / 180;
    const lat2Rad = point2.lat * Math.PI / 180;
    
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1Rad) * Math.cos(lat2Rad) * 
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    
    return Math.max(0, R * c); // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡πà‡∏≤‡∏•‡∏ö
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡πÅ‡∏•‡∏∞ error handling
export const findClosestPointOnLineSegment = (
    point: Coordinate,
    lineStart: Coordinate,
    lineEnd: Coordinate
): Coordinate => {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤ input ‡πÅ‡∏•‡∏∞‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô null/undefined
    if (!point || !lineStart || !lineEnd) {
        return lineStart || { lat: 0, lng: 0 };
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ
    if (!isFinite(point.lat) || !isFinite(point.lng) || 
        !isFinite(lineStart.lat) || !isFinite(lineStart.lng) ||
        !isFinite(lineEnd.lat) || !isFinite(lineEnd.lng)) {
        return lineStart;
    }

    const A = point.lat - lineStart.lat;
    const B = point.lng - lineStart.lng;
    const C = lineEnd.lat - lineStart.lat;
    const D = lineEnd.lng - lineStart.lng;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;

    // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á - ‡πÉ‡∏ä‡πâ threshold ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤
    if (lenSq < 1e-12) {
        return { lat: lineStart.lat, lng: lineStart.lng };
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì parameter ‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á [0, 1]
    let param = dot / lenSq;
    param = Math.max(0, Math.min(1, param));

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    const result = {
        lat: lineStart.lat + param * C,
        lng: lineStart.lng + param * D
    };

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô
    if (!isFinite(result.lat) || !isFinite(result.lng)) {
        return { lat: lineStart.lat, lng: lineStart.lng };
    }

    return result;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á endpoints)
export const isPointOnSubMainPipe = (
    point: Coordinate,
    subMainPipe: SubMainPipe,
    threshold: number = 5
): boolean => {
    if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
        return false;
    }

    // üî• ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö endpoints ‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ö‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡πà‡∏≠)
    const startPoint = subMainPipe.coordinates[0];
    const endPoint = subMainPipe.coordinates[subMainPipe.coordinates.length - 1];
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    const distanceToStart = calculateDistanceBetweenPoints(point, startPoint);
    if (distanceToStart <= threshold) {
        return true;
    }
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
    const distanceToEnd = calculateDistanceBetweenPoints(point, endPoint);
    if (distanceToEnd <= threshold) {
        return true;
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö line segments ‡∏ï‡∏≤‡∏°‡πÄ‡∏î‡∏¥‡∏°
    for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
        const start = subMainPipe.coordinates[i];
        const end = subMainPipe.coordinates[i + 1];
        
        const closestPoint = findClosestPointOnLineSegment(point, start, end);
        const distance = calculateDistanceBetweenPoints(point, closestPoint);
        
        if (distance <= threshold) {
            return true;
        }
    }
    
    return false;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô)
export const findClosestConnectionPoint = (
    point: Coordinate,
    subMainPipe: SubMainPipe
): Coordinate | null => {
    if (!subMainPipe.coordinates || subMainPipe.coordinates.length < 2) {
        return null;
    }

    let closestPoint: Coordinate | null = null;
    let minDistance = Infinity;
    let bestSegmentIndex = -1;

    // üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏à‡∏∏‡∏î‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î - ‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö perpendicular projection
    for (let i = 0; i < subMainPipe.coordinates.length - 1; i++) {
        const segmentStart = subMainPipe.coordinates[i];
        const segmentEnd = subMainPipe.coordinates[i + 1];
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏â‡∏≤‡∏¢‡∏•‡∏á‡∏ö‡∏ô line segment (perpendicular projection)
        const pointOnSegment = findClosestPointOnLineSegment(point, segmentStart, segmentEnd);
        const distance = calculateDistanceBetweenPoints(point, pointOnSegment);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏â‡∏≤‡∏¢‡∏•‡∏á‡∏ô‡∏±‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ö‡∏ô segment ‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏õ‡πá‡∏ô endpoint
        const segmentLength = calculateDistanceBetweenPoints(segmentStart, segmentEnd);
        const distanceFromStart = calculateDistanceBetweenPoints(segmentStart, pointOnSegment);
        const distanceFromEnd = calculateDistanceBetweenPoints(segmentEnd, pointOnSegment);
        
        // ‡∏ñ‡πâ‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏â‡∏≤‡∏¢‡∏•‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ô segment (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà endpoint) ‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
        const isWithinSegment = distanceFromStart < segmentLength - 0.001 && distanceFromEnd < segmentLength - 0.001;
        const adjustedDistance = isWithinSegment ? distance * 0.8 : distance; // ‡∏•‡∏î‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å 20% ‡∏ñ‡πâ‡∏≤‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô segment
        
        if (adjustedDistance < minDistance) {
            minDistance = adjustedDistance;
            closestPoint = {
                lat: parseFloat(pointOnSegment.lat.toFixed(8)), // ‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏©‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
                lng: parseFloat(pointOnSegment.lng.toFixed(8))
            };
            bestSegmentIndex = i;
        }
    }
    
    // üîß ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö endpoints ‡πÅ‡∏¢‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏≤‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏•‡∏≤‡∏î
    const startPoint = subMainPipe.coordinates[0];
    const endPoint = subMainPipe.coordinates[subMainPipe.coordinates.length - 1];
    
    const distanceToStart = calculateDistanceBetweenPoints(point, startPoint);
    const distanceToEnd = calculateDistanceBetweenPoints(point, endPoint);
    
    // ‡∏ñ‡πâ‡∏≤ endpoint ‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏ß‡πà‡∏≤ 2 ‡πÄ‡∏°‡∏ï‡∏£ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ endpoint
    if (distanceToStart <= 2.0 && distanceToStart < minDistance) {
        closestPoint = { lat: startPoint.lat, lng: startPoint.lng };
        minDistance = distanceToStart;
        bestSegmentIndex = 0;
    }
    
    if (distanceToEnd <= 2.0 && distanceToEnd < minDistance) {
        closestPoint = { lat: endPoint.lat, lng: endPoint.lng };
        minDistance = distanceToEnd;
        bestSegmentIndex = subMainPipe.coordinates.length - 2;
    }
    
    return closestPoint;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡πÅ‡∏ñ‡∏ß (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡∏°‡πà - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô + caching)
export const groupPlantsByRows = (plants: PlantLocation[]): PlantLocation[][] => {
    if (plants.length === 0) return [];

    // üöÄ Check cache first
    const currentHash = createPlantsHash(plants);
    if (plantGroupCache && plantGroupCache.plantsHash === currentHash) {
        return plantGroupCache.rowGroups;
    }

    const groups: PlantLocation[][] = [];
    const tolerance = 0.000005; // ~0.5 ‡πÄ‡∏°‡∏ï‡∏£ tolerance - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
    const rotationInfo = hasRotation(plants);
    
    let plantsToGroup: { plant: PlantLocation, transformedPosition: Coordinate }[] = [];
    
    if (rotationInfo.hasRotation) {
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡πâ‡∏ß
        plantsToGroup = plants.map(plant => ({
            plant,
            transformedPosition: transformToRotatedCoordinate(plant.position, rotationInfo.center, rotationInfo.rotationAngle)
        }));
    } else {
        // ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
        plantsToGroup = plants.map(plant => ({
            plant,
            transformedPosition: plant.position
        }));
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á clusters ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ lat coordinate ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    const plantsByLat = [...plantsToGroup].sort((a, b) => a.transformedPosition.lat - b.transformedPosition.lat);
    
    for (const plantData of plantsByLat) {
        let addedToGroup = false;
        
        // ‡∏´‡∏≤‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ lat ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô
        for (const group of groups) {
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lat ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏à‡∏≤‡∏Å‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
            const avgLat = group.reduce((sum, p) => {
                const transformedPos = rotationInfo.hasRotation 
                    ? transformToRotatedCoordinate(p.position, rotationInfo.center, rotationInfo.rotationAngle)
                    : p.position;
                return sum + transformedPos.lat;
            }, 0) / group.length;
            
            if (Math.abs(plantData.transformedPosition.lat - avgLat) <= tolerance) {
                group.push(plantData.plant);
                addedToGroup = true;
                break;
            }
        }
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
        if (!addedToGroup) {
            groups.push([plantData.plant]);
        }
    }
    
    // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ 2 ‡∏ï‡πâ‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏° lng ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    const filteredGroups = groups
        .filter(group => group.length >= 2)
        .map(group => group.sort((a, b) => {
            const aTransformed = rotationInfo.hasRotation 
                ? transformToRotatedCoordinate(a.position, rotationInfo.center, rotationInfo.rotationAngle)
                : a.position;
            const bTransformed = rotationInfo.hasRotation 
                ? transformToRotatedCoordinate(b.position, rotationInfo.center, rotationInfo.rotationAngle)
                : b.position;
            return aTransformed.lng - bTransformed.lng;
        }));
    
    // üöÄ Update cache with row groups (will be completed when both functions are computed)
    if (!plantGroupCache || plantGroupCache.plantsHash !== currentHash) {
        plantGroupCache = {
            plantsHash: currentHash,
            rowGroups: filteredGroups,
            columnGroups: plantGroupCache?.plantsHash === currentHash ? plantGroupCache.columnGroups : []
        };
    } else {
        plantGroupCache.rowGroups = filteredGroups;
    }
    
    return filteredGroups;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡∏°‡πà - ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô + caching)
export const groupPlantsByColumns = (plants: PlantLocation[]): PlantLocation[][] => {
    if (plants.length === 0) return [];

    // üöÄ Check cache first
    const currentHash = createPlantsHash(plants);
    if (plantGroupCache && plantGroupCache.plantsHash === currentHash && plantGroupCache.columnGroups.length > 0) {
        return plantGroupCache.columnGroups;
    }

    const groups: PlantLocation[][] = [];
    const tolerance = 0.000005; // ~0.5 ‡πÄ‡∏°‡∏ï‡∏£ tolerance - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
    const rotationInfo = hasRotation(plants);
    
    let plantsToGroup: { plant: PlantLocation, transformedPosition: Coordinate }[] = [];
    
    if (rotationInfo.hasRotation) {
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡πâ‡∏ß
        plantsToGroup = plants.map(plant => ({
            plant,
            transformedPosition: transformToRotatedCoordinate(plant.position, rotationInfo.center, rotationInfo.rotationAngle)
        }));
    } else {
        // ‡πÉ‡∏ä‡πâ‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏î‡∏¥‡∏°‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
        plantsToGroup = plants.map(plant => ({
            plant,
            transformedPosition: plant.position
        }));
    }
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á clusters ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ lng coordinate ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    const plantsByLng = [...plantsToGroup].sort((a, b) => a.transformedPosition.lng - b.transformedPosition.lng);
    
    for (const plantData of plantsByLng) {
        let addedToGroup = false;
        
        // ‡∏´‡∏≤‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ lng ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô
        for (const group of groups) {
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lng ‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏à‡∏≤‡∏Å‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
            const avgLng = group.reduce((sum, p) => {
                const transformedPos = rotationInfo.hasRotation 
                    ? transformToRotatedCoordinate(p.position, rotationInfo.center, rotationInfo.rotationAngle)
                    : p.position;
                return sum + transformedPos.lng;
            }, 0) / group.length;
            
            if (Math.abs(plantData.transformedPosition.lng - avgLng) <= tolerance) {
                group.push(plantData.plant);
                addedToGroup = true;
                break;
            }
        }
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
        if (!addedToGroup) {
            groups.push([plantData.plant]);
        }
    }
    
    // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ 2 ‡∏ï‡πâ‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡∏≤‡∏° lat ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
    const filteredGroups = groups
        .filter(group => group.length >= 2)
        .map(group => group.sort((a, b) => {
            const aTransformed = rotationInfo.hasRotation 
                ? transformToRotatedCoordinate(a.position, rotationInfo.center, rotationInfo.rotationAngle)
                : a.position;
            const bTransformed = rotationInfo.hasRotation 
                ? transformToRotatedCoordinate(b.position, rotationInfo.center, rotationInfo.rotationAngle)
                : b.position;
            return aTransformed.lat - bTransformed.lat;
        }));
    
    // üöÄ Update cache with column groups
    if (!plantGroupCache || plantGroupCache.plantsHash !== currentHash) {
        plantGroupCache = {
            plantsHash: currentHash,
            rowGroups: plantGroupCache?.plantsHash === currentHash ? plantGroupCache.rowGroups : [],
            columnGroups: filteredGroups
        };
    } else {
        plantGroupCache.columnGroups = filteredGroups;
    }
    
    return filteredGroups;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢ (‡πÇ‡∏´‡∏°‡∏î A: ‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ö‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ)
export const findPlantsInLateralPath = (
    startPoint: Coordinate,
    endPoint: Coordinate,
    plants: PlantLocation[],
    placementMode: 'over_plants' | 'between_plants',
    snapThreshold: number = 5
): PlantLocation[] => {
    if (placementMode === 'over_plants') {
        return findPlantsInOverPlantsMode(startPoint, endPoint, plants, snapThreshold);
    } else {
        return findPlantsInBetweenPlantsMode(startPoint, endPoint, plants, snapThreshold);
    }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ö‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
export const findPlantsInOverPlantsMode = (
    startPoint: Coordinate,
    endPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number = 5
): PlantLocation[] => {
    if (!startPoint || !endPoint || !plants || plants.length === 0) {
        return [];
    }

    const result = computeOverPlantsMode(startPoint, endPoint, plants, snapThreshold, 'rows');
    return result.selectedPlants;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î‡∏ß‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
export const findPlantsInBetweenPlantsMode = (
    startPoint: Coordinate,
    endPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number = 5
): PlantLocation[] => {
    if (!startPoint || !endPoint || !plants || plants.length === 0) {
        return [];
    }

    const result = computeBetweenPlantsMode(startPoint, endPoint, plants, snapThreshold, 'rows');
    return result.selectedPlants;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡πÄ‡∏ß‡∏Ñ‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÅ‡∏•‡∏∞‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ä‡∏±‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢‡πÉ‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î lat/lng (‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å)
const normalizeVector = (v: { lat: number; lng: number }): { lat: number; lng: number } => {
    const len = Math.sqrt(v.lat * v.lat + v.lng * v.lng) || 1;
    return { lat: v.lat / len, lng: v.lng / len };
};

const subtract = (a: Coordinate, b: Coordinate): { lat: number; lng: number } => ({
    lat: a.lat - b.lat,
    lng: a.lng - b.lng,
});

const scaleAndAdd = (origin: Coordinate, dir: { lat: number; lng: number }, t: number): Coordinate => ({
    lat: origin.lat + dir.lat * t,
    lng: origin.lng + dir.lng * t,
});

const dot = (a: { lat: number; lng: number }, b: { lat: number; lng: number }) => a.lat * b.lat + a.lng * b.lng;

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
const transformToRotatedCoordinate = (point: Coordinate, center: Coordinate, rotationAngle: number): Coordinate => {
    // ‡πÅ‡∏õ‡∏•‡∏á‡∏°‡∏∏‡∏°‡∏à‡∏≤‡∏Å‡∏≠‡∏á‡∏®‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏£‡πÄ‡∏î‡∏µ‡∏¢‡∏ô
    const angleRadians = (rotationAngle * Math.PI) / 180;
    const cos = Math.cos(-angleRadians); // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á‡∏Å‡∏•‡∏±‡∏ö
    const sin = Math.sin(-angleRadians);

    // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
    const dx = point.lat - center.lat;
    const dy = point.lng - center.lng;

    // ‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏∏‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏î‡∏¥‡∏°
    const rotatedLat = center.lat + dx * cos - dy * sin;
    const rotatedLng = center.lng + dx * sin + dy * cos;

    return { lat: rotatedLat, lng: rotatedLng };
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
const getPlantGroupCenter = (plants: PlantLocation[]): Coordinate => {
    if (plants.length === 0) return { lat: 0, lng: 0 };
    
    const totalLat = plants.reduce((sum, plant) => sum + plant.position.lat, 0);
    const totalLng = plants.reduce((sum, plant) => sum + plant.position.lng, 0);
    
    return {
        lat: totalLat / plants.length,
        lng: totalLng / plants.length
    };
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
const hasRotation = (plants: PlantLocation[]): { hasRotation: boolean; rotationAngle: number; center: Coordinate } => {
    if (plants.length === 0) {
        return { hasRotation: false, rotationAngle: 0, center: { lat: 0, lng: 0 } };
    }
    
    // ‡πÉ‡∏ä‡πâ‡∏°‡∏∏‡∏°‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏≤‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    const plantWithRotation = plants.find(plant => plant.rotationAngle !== undefined);
    const rotationAngle = plantWithRotation ? plantWithRotation.rotationAngle || 0 : 0;
    const center = getPlantGroupCenter(plants);
    
    return {
        hasRotation: Math.abs(rotationAngle) > 0.01, // tolerance ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÜ
        rotationAngle,
        center
    };
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏≤‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏≤‡∏ß‡πà‡∏≤‡∏Ñ‡∏ß‡∏£‡∏≠‡∏¥‡∏á‡πÅ‡∏ñ‡∏ß (rows) ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå (columns) - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥
const getDragOrientation = (start: Coordinate, end: Coordinate, plants?: PlantLocation[]): 'rows' | 'columns' => {
    let dLat = Math.abs(end.lat - start.lat);
    let dLng = Math.abs(end.lng - start.lng);
    
    // ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô ‡πÉ‡∏´‡πâ‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
    if (plants && plants.length > 0) {
        const rotationInfo = hasRotation(plants);
        
        if (rotationInfo.hasRotation) {
            // ‡πÅ‡∏õ‡∏•‡∏á‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÅ‡∏•‡∏∞‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏´‡∏°‡∏∏‡∏ô‡πÅ‡∏•‡πâ‡∏ß
            const transformedStart = transformToRotatedCoordinate(start, rotationInfo.center, rotationInfo.rotationAngle);
            const transformedEnd = transformToRotatedCoordinate(end, rotationInfo.center, rotationInfo.rotationAngle);
            
            dLat = Math.abs(transformedEnd.lat - transformedStart.lat);
            dLng = Math.abs(transformedEnd.lng - transformedStart.lng);
        }
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå layout ‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç performance ‡πÅ‡∏•‡∏∞ division by zero
        // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏û‡∏≠‡πÄ‡∏´‡∏°‡∏≤‡∏∞
        if (plants.length > 10 && plants.length <= 1000) { // ‡∏à‡∏≥‡∏Å‡∏±‡∏î upper bound ‡πÄ‡∏û‡∏∑‡πà‡∏≠ performance
            try {
                const rows = groupPlantsByRows(plants);
                const cols = groupPlantsByColumns(plants);
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö validity ‡∏Ç‡∏≠‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                if (Array.isArray(rows) && Array.isArray(cols)) {
                    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏° - ‡πÄ‡∏û‡∏¥‡πà‡∏° safety checks
                    const avgRowSize = rows.length > 0 ? 
                        rows.filter(row => Array.isArray(row)).reduce((sum, row) => sum + row.length, 0) / rows.length : 0;
                    const avgColSize = cols.length > 0 ? 
                        cols.filter(col => Array.isArray(col)).reduce((sum, col) => sum + col.length, 0) / cols.length : 0;
                    
                    // ‡∏ñ‡πâ‡∏≤‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏ñ‡∏ß‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÅ‡∏ñ‡∏ß
                    const rowClearness = avgRowSize * rows.length;
                    const colClearness = avgColSize * cols.length;
                    
                    // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç division by zero ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° bounds checking
                    const maxClearness = Math.max(rowClearness, colClearness);
                    if (maxClearness > 0.1) { // threshold ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô very small numbers
                        const layoutDifference = Math.abs(rowClearness - colClearness) / maxClearness;
                        if (isFinite(layoutDifference) && layoutDifference > 0.3) { // 30% difference threshold
                            return rowClearness > colClearness ? 'rows' : 'columns';
                        }
                    }
                }
            } catch (error) {
                // Silent fallback - ‡∏ñ‡πâ‡∏≤ grouping fail ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ distance-based logic
                console.warn('Layout analysis failed, falling back to distance-based orientation', error);
            }
        }
    }
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏™‡∏¥‡∏ô‡πÉ‡∏à‡∏î‡πâ‡∏ß‡∏¢ threshold ‡πÅ‡∏ö‡∏ö adaptive
    const totalDistance = dLat + dLng;
    const adaptiveThreshold = totalDistance > 0.0001 ? 0.2 : 0.1; // ‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏¢‡∏≤‡∏ß ‡πÉ‡∏ä‡πâ threshold ‡∏ó‡∏µ‡πà‡∏´‡∏•‡∏ß‡∏°‡∏Å‡∏ß‡πà‡∏≤
    
    if (dLat > dLng * (1 + adaptiveThreshold)) {
        return 'columns'; // ‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á (‡πÄ‡∏´‡∏ô‡∏∑‡∏≠-‡πÉ‡∏ï‡πâ)
    } else if (dLng > dLat * (1 + adaptiveThreshold)) {
        return 'rows'; // ‡πÅ‡∏ô‡∏ß‡∏ô‡∏≠‡∏ô (‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å-‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏ï‡∏Å)
    } else {
        // ‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏Å‡∏±‡∏ô ‡πÉ‡∏´‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        const ratio = dLat / dLng;
        
        // ‡∏ñ‡πâ‡∏≤‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á 1:1 ‡∏°‡∏≤‡∏Å ‡πÉ‡∏´‡πâ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏¢‡∏≤‡∏ß‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
        if (Math.abs(ratio - 1) < 0.05) {
            // Very close to diagonal - choose based on slight preference
            return dLat > dLng ? 'columns' : 'rows';
        }
        
        return ratio > 1 ? 'columns' : 'rows';
    }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ô‡∏ß‡πÅ‡∏ñ‡∏ß‡∏à‡∏≤‡∏Å‡∏û‡∏≠‡∏¢‡∏ï‡πå‡∏ï‡πâ‡∏ô-‡∏õ‡∏•‡∏≤‡∏¢‡πÉ‡∏ô‡πÅ‡∏ñ‡∏ß (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô)
const directionFromPlantsLine = (plants: PlantLocation[]): { lat: number; lng: number } => {
    if (!plants || plants.length < 2) return { lat: 0, lng: 1 };
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
    const rotationInfo = hasRotation(plants);
    
    let sortedPlants: PlantLocation[];
    
    if (rotationInfo.hasRotation) {
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° lng ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
        const plantsWithTransformed = plants.map(plant => ({
            plant,
            transformedPosition: transformToRotatedCoordinate(plant.position, rotationInfo.center, rotationInfo.rotationAngle)
        }));
        
        sortedPlants = plantsWithTransformed
            .sort((a, b) => a.transformedPosition.lng - b.transformedPosition.lng)
            .map(item => item.plant);
    } else {
        sortedPlants = [...plants].sort((a, b) => a.position.lng - b.position.lng);
    }
    
    const first = sortedPlants[0].position;
    const last = sortedPlants[sortedPlants.length - 1].position;
    return normalizeVector({ lat: last.lat - first.lat, lng: last.lng - first.lng });
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏à‡∏≤‡∏Å‡∏û‡∏≠‡∏¢‡∏ï‡πå‡∏ï‡πâ‡∏ô-‡∏õ‡∏•‡∏≤‡∏¢‡πÉ‡∏ô‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô)
const directionFromPlantsColumn = (plants: PlantLocation[]): { lat: number; lng: number } => {
    if (!plants || plants.length < 2) return { lat: 1, lng: 0 };
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
    const rotationInfo = hasRotation(plants);
    
    let sortedPlants: PlantLocation[];
    
    if (rotationInfo.hasRotation) {
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏ï‡∏≤‡∏° lat ‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß
        const plantsWithTransformed = plants.map(plant => ({
            plant,
            transformedPosition: transformToRotatedCoordinate(plant.position, rotationInfo.center, rotationInfo.rotationAngle)
        }));
        
        sortedPlants = plantsWithTransformed
            .sort((a, b) => a.transformedPosition.lat - b.transformedPosition.lat)
            .map(item => item.plant);
    } else {
        sortedPlants = [...plants].sort((a, b) => a.position.lat - b.position.lat);
    }
    
    const first = sortedPlants[0].position;
    const last = sortedPlants[sortedPlants.length - 1].position;
    return normalizeVector({ lat: last.lat - first.lat, lng: last.lng - first.lng });
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì adaptive snap threshold ‡∏ï‡∏≤‡∏°‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç performance ‡πÅ‡∏•‡∏∞ safety issues
const calculateAdaptiveSnapThreshold = (
    baseThreshold: number,
    plants: PlantLocation[],
    pipeDistance: number
): number => {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö input safety
    if (!plants || plants.length === 0 || !isFinite(baseThreshold) || !isFinite(pipeDistance)) {
        return Math.max(5, baseThreshold);
    }
    
    // ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç O(n¬≤) performance ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ sampling ‡πÅ‡∏ó‡∏ô
    let totalSpacing = 0;
    let spacingCount = 0;
    const maxSampleSize = Math.min(plants.length, 20); // ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠ performance
    
    // ‡πÉ‡∏ä‡πâ stride sampling ‡πÅ‡∏ó‡∏ô nested loops
    const stride = Math.max(1, Math.floor(plants.length / maxSampleSize));
    
    for (let i = 0; i < plants.length - stride; i += stride) {
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö position validity ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ
        if (!plants[i]?.position || !plants[i + stride]?.position) continue;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡πà‡∏≤‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô finite numbers
        const pos1 = plants[i].position;
        const pos2 = plants[i + stride].position;
        
        if (!isFinite(pos1.lat) || !isFinite(pos1.lng) || 
            !isFinite(pos2.lat) || !isFinite(pos2.lng)) {
            continue;
        }
        
        const distance = calculateDistanceBetweenPoints(pos1, pos2);
        if (distance > 0 && distance < 100 && isFinite(distance)) { // ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ä‡πà‡∏ß‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á
            totalSpacing += distance;
            spacingCount++;
        }
    }
    
    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì average spacing ‡πÅ‡∏ö‡∏ö fallback safety
    let avgSpacing = baseThreshold;
    if (spacingCount > 0 && totalSpacing > 0) {
        avgSpacing = totalSpacing / spacingCount;
    }
    
    // ‡∏õ‡∏£‡∏±‡∏ö threshold ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏ô‡∏≤‡πÅ‡∏ô‡πà‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏ó‡πà‡∏≠ - ‡πÄ‡∏û‡∏¥‡πà‡∏° safety checks
    let adaptiveThreshold = baseThreshold;
    
    // ‡πÉ‡∏ä‡πâ safe comparison ‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
    if (isFinite(avgSpacing) && avgSpacing > baseThreshold && avgSpacing < baseThreshold * 5) {
        adaptiveThreshold = Math.min(avgSpacing * 0.8, baseThreshold * 2);
    }
    
    // ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏ó‡πà‡∏≠ - ‡πÄ‡∏û‡∏¥‡πà‡∏° boundary checks
    if (isFinite(pipeDistance)) {
        if (pipeDistance > 50 && pipeDistance < 1000) { // ‡∏à‡∏≥‡∏Å‡∏±‡∏î upper bound
            adaptiveThreshold = Math.min(adaptiveThreshold * 1.3, baseThreshold * 2); // ‡∏•‡∏î multiplier
        } else if (pipeDistance < 20 && pipeDistance > 0) {
            adaptiveThreshold = Math.max(adaptiveThreshold * 0.8, baseThreshold * 0.6); // ‡∏•‡∏î‡∏Å‡∏≤‡∏£ penalty
        }
    }
    
    // Final safety bounds
    const result = Math.max(3, Math.min(60, adaptiveThreshold));
    return isFinite(result) ? result : baseThreshold;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≤‡∏£ snap ‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ adaptive threshold
export const computeAlignedLateral = (
    startPoint: Coordinate,
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    placementMode: 'over_plants' | 'between_plants',
    snapThreshold: number = 20
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {
    if (!startPoint || !rawEndPoint) {
        return { alignedEnd: rawEndPoint, selectedPlants: [], snappedStart: startPoint || rawEndPoint };
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ - ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å start ‡πÑ‡∏õ rawEnd
    if (!plants || plants.length === 0) {
        return { alignedEnd: rawEndPoint, selectedPlants: [], snappedStart: startPoint };
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏•‡∏∞ adaptive threshold
    const pipeDistance = calculateDistanceBetweenPoints(startPoint, rawEndPoint);
    const adaptiveThreshold = calculateAdaptiveSnapThreshold(snapThreshold, plants, pipeDistance);

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏à‡∏≤‡∏Å startPoint ‡πÑ‡∏õ rawEndPoint (‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ)
    const direction = getDragOrientation(startPoint, rawEndPoint, plants);

    if (placementMode === 'over_plants') {
        return computeOverPlantsMode(startPoint, rawEndPoint, plants, adaptiveThreshold, direction);
    } else {
        return computeBetweenPlantsMode(startPoint, rawEndPoint, plants, adaptiveThreshold, direction);
    }
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡πà‡∏≠‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á
export const computeAlignedLateralFromMainPipe = (
    snappedStartPoint: Coordinate, // ‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà snap ‡πÑ‡∏õ‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    placementMode: 'over_plants' | 'between_plants',
    snapThreshold: number = 20
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {
    if (!snappedStartPoint || !rawEndPoint) {
        return { alignedEnd: rawEndPoint, selectedPlants: [], snappedStart: snappedStartPoint || rawEndPoint };
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ - ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å snappedStart ‡πÑ‡∏õ rawEnd
    if (!plants || plants.length === 0) {
        return { alignedEnd: rawEndPoint, selectedPlants: [], snappedStart: snappedStartPoint };
    }

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏à‡∏≤‡∏Å snappedStartPoint ‡πÑ‡∏õ rawEndPoint (‡∏û‡∏¥‡∏à‡∏≤‡∏£‡∏ì‡∏≤‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ)
    const direction = getDragOrientation(snappedStartPoint, rawEndPoint, plants);

    if (placementMode === 'over_plants') {
        return computeOverPlantsModeFromMainPipe(snappedStartPoint, rawEndPoint, plants, snapThreshold, direction);
    } else {
        return computeBetweenPlantsModeFromMainPipe(snappedStartPoint, rawEndPoint, plants, snapThreshold, direction);
    }
};

// ‡πÇ‡∏´‡∏°‡∏î A: ‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ö‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏)
export const computeOverPlantsMode = (
    initialStartPoint: Coordinate,
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number,
    direction: 'rows' | 'columns'
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {
    const rows = groupPlantsByRows(plants);
    const cols = groupPlantsByColumns(plants);
    
    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°
    const findClosestPlantToStart = (group: PlantLocation[]): { plant: PlantLocation, distance: number } | null => {
        if (group.length === 0) return null;
        let closest: { plant: PlantLocation, distance: number } | null = null;
        group.forEach(p => {
            const dist = calculateDistanceBetweenPoints(initialStartPoint, p.position);
            if (!closest || dist < closest.distance) {
                closest = { plant: p, distance: dist };
            }
        });
        return closest;
    };
    
    // ‡∏´‡∏≤‡πÅ‡∏ñ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç: "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏ß‡∏¥‡πà‡∏á‡∏ú‡πà‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡πÉ‡∏Ñ‡∏£‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î"
    interface OverPlantsAlignment {
        type: 'row' | 'col';
        plants: PlantLocation[];
        firstPlantDistance: number; // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å" ‡∏à‡∏≤‡∏Å initialStartPoint
        firstPlant: PlantLocation; // ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        centerLine: { start: Coordinate; end: Coordinate };
    }
    
    let bestAlignment: OverPlantsAlignment | null = null;

    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    const targetGroups = direction === 'rows' ? rows : cols;
    const groupType = direction === 'rows' ? 'row' : 'col';

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    targetGroups.forEach((group, groupIndex) => {
        if (group.length < 2) return;
        
        const closestToStart = findClosestPlantToStart(group);
        if (!closestToStart) return;
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° snapThreshold ‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ snap ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const adjustedSnapThreshold = snapThreshold * 2; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 2 ‡πÄ‡∏ó‡πà‡∏≤
        
        // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ó‡∏µ‡πà‡∏°‡∏µ "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å" ‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ snapThreshold
        if (closestToStart.distance <= adjustedSnapThreshold && 
            (!bestAlignment || closestToStart.distance < bestAlignment.firstPlantDistance)) {
            
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏° - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏ß‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ snap ‡πÑ‡∏î‡πâ
            let fullCenterLine: { start: Coordinate; end: Coordinate };
            
            if (direction === 'rows') {
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß: ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lng
                const sortedByLng = [...group].sort((a, b) => a.position.lng - b.position.lng);
                fullCenterLine = {
                    start: sortedByLng[0].position,
                    end: sortedByLng[sortedByLng.length - 1].position
                };
            } else {
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: ‡πÉ‡∏ä‡πâ lng coordinate ‡∏ó‡∏µ‡πà‡∏Ñ‡∏á‡∏ó‡∏µ‡πà ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lat
                const sortedByLat = [...group].sort((a, b) => a.position.lat - b.position.lat);
                const avgLng = group.reduce((sum, p) => sum + p.position.lng, 0) / group.length;
                fullCenterLine = {
                    start: { lat: sortedByLat[0].position.lat, lng: avgLng },
                    end: { lat: sortedByLat[sortedByLat.length - 1].position.lat, lng: avgLng }
                };
            }
            
            bestAlignment = {
                type: groupType,
                plants: group,
                firstPlantDistance: closestToStart.distance,
                firstPlant: closestToStart.plant,
                centerLine: fullCenterLine
            };
        }
    });

    if (!bestAlignment) {
        return { alignedEnd: rawEndPoint, selectedPlants: [], snappedStart: initialStartPoint };
    }

    // Type assertion to help TypeScript understand bestAlignment is not null
    const alignment = bestAlignment as OverPlantsAlignment;

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì snappedStart: ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà projection ‡∏Ç‡∏≠‡∏á initialStartPoint ‡∏•‡∏á‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    // ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏±‡∏ö‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°
    const projectedStart = findClosestPointOnLineSegment(initialStartPoint, alignment.centerLine.start, alignment.centerLine.end);
    const distanceToProjection = calculateDistanceBetweenPoints(initialStartPoint, projectedStart);
    
    // ‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÑ‡∏Å‡∏•‡∏Å‡∏ß‡πà‡∏≤ snapThreshold ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°
    const snappedStart = distanceToProjection <= snapThreshold ? projectedStart : initialStartPoint;

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏°‡∏≤‡∏™‡πå
    // ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏õ‡∏•‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏•‡∏≤‡∏Å‡πÑ‡∏õ
    const alignedEnd = findClosestPointOnLineSegment(rawEndPoint, alignment.centerLine.start, alignment.centerLine.end);
    
    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏à‡∏≤‡∏Å‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
    const selectedPlants = alignment.plants.filter((plant, index) => {
        // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const plantProjected = findClosestPointOnLineSegment(plant.position, alignment.centerLine.start, alignment.centerLine.end);
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á lateral pipe ‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á
        const totalPipeDistance = calculateDistanceBetweenPoints(snappedStart, alignedEnd);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
        let isInRange = false;
        
        if (alignment.type === 'row') {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ñ‡∏ß: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° lng ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd
            const minLng = Math.min(snappedStart.lng, alignedEnd.lng);
            const maxLng = Math.max(snappedStart.lng, alignedEnd.lng);
            const buffer = Math.max(0.000001, (maxLng - minLng) * 0.05); // 5% buffer ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î
            isInRange = plantProjected.lng >= minLng - buffer && plantProjected.lng <= maxLng + buffer;
        } else {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° lat ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd
            const minLat = Math.min(snappedStart.lat, alignedEnd.lat);
            const maxLat = Math.max(snappedStart.lat, alignedEnd.lat);
            const buffer = Math.max(0.000001, (maxLat - minLat) * 0.05); // 5% buffer ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î
            isInRange = plantProjected.lat >= minLat - buffer && plantProjected.lat <= maxLat + buffer;
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ - ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ adaptive ‡∏ï‡∏≤‡∏° density
        const distanceToLine = calculateDistanceBetweenPoints(plant.position, plantProjected);
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì tolerance ‡πÅ‡∏ö‡∏ö adaptive based on pipe length ‡πÅ‡∏•‡∏∞ plant density
        let adaptiveTolerance = 2.0; // default 2 meters
        if (totalPipeDistance > 0) {
            // ‡∏ñ‡πâ‡∏≤‡∏ó‡πà‡∏≠‡∏™‡∏±‡πâ‡∏ô (< 10m) ‡πÉ‡∏ä‡πâ tolerance ‡πÄ‡∏•‡πá‡∏Å, ‡∏ñ‡πâ‡∏≤‡∏ó‡πà‡∏≠‡∏¢‡∏≤‡∏ß (> 50m) ‡πÉ‡∏ä‡πâ tolerance ‡πÉ‡∏´‡∏ç‡πà
            adaptiveTolerance = Math.max(1.0, Math.min(4.0, totalPipeDistance / 25)); // 1-4 ‡πÄ‡∏°‡∏ï‡∏£
        }
        
        const result = isInRange && distanceToLine <= adaptiveTolerance;
        
        return result;
    });

    return { alignedEnd, selectedPlants, snappedStart };
};

// ‡πÇ‡∏´‡∏°‡∏î B: ‡∏ß‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ï‡∏≤‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏)
export const computeBetweenPlantsMode = (
    initialStartPoint: Coordinate,
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number,
    direction: 'rows' | 'columns'
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {

    const rows = groupPlantsByRows(plants);
    const cols = groupPlantsByColumns(plants);
    
    // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢: ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
    const findClosestPlantToStartInPair = (group1: PlantLocation[], group2: PlantLocation[]): { plant: PlantLocation, distance: number } | null => {
        const allPlants = [...group1, ...group2];
        if (allPlants.length === 0) return null;
        
        let closest: { plant: PlantLocation, distance: number } | null = null;
        allPlants.forEach(p => {
            const dist = calculateDistanceBetweenPoints(initialStartPoint, p.position);
            if (!closest || dist < closest.distance) {
                closest = { plant: p, distance: dist };
            }
        });
        return closest;
    };
    
    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    const targetGroups = direction === 'rows' ? rows : cols;
    const groupType = direction === 'rows' ? 'between_rows' : 'between_cols';
    
    // ‡∏´‡∏≤ "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å" ‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    interface BetweenPlantsAlignment {
        type: 'between_rows' | 'between_cols';
        row1: PlantLocation[];
        row2: PlantLocation[];
        firstPlantDistance: number; // ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å" ‡∏à‡∏≤‡∏Å initialStartPoint
        firstPlant: PlantLocation; // ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Ñ‡∏π‡πà‡∏ô‡∏µ‡πâ
        centerLine: { start: Coordinate; end: Coordinate };
    }
    
    let bestAlignment: BetweenPlantsAlignment | null = null;

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô
    for (let i = 0; i < targetGroups.length - 1; i++) {
        const group1 = targetGroups[i];
        const group2 = targetGroups[i + 1];
        
        if (group1.length < 2 || group2.length < 2) continue;
        
        // üîß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå (‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡πÄ‡∏Å‡∏¥‡∏ô 15 ‡πÄ‡∏°‡∏ï‡∏£)
        const group1CenterCheck = getPlantGroupCenter(group1);
        const group2CenterCheck = getPlantGroupCenter(group2);
        const distanceBetweenGroupsCheck = calculateDistanceBetweenPoints(group1CenterCheck, group2CenterCheck);
        
        // ‡∏ñ‡πâ‡∏≤‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏≠‡∏¢‡∏π‡πà‡πÑ‡∏Å‡∏•‡∏Å‡∏±‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô 15 ‡πÄ‡∏°‡∏ï‡∏£ ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ
        if (distanceBetweenGroupsCheck > 15.0) {
            continue;
        }
        
        const closestToStart = findClosestPlantToStartInPair(group1, group2);
        if (!closestToStart) continue;
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏° snapThreshold ‡πÉ‡∏´‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ snap ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const adjustedSnapThreshold = snapThreshold * 3; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 3 ‡πÄ‡∏ó‡πà‡∏≤‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏î‡πâ‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏ß‡πà‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        const group1CenterCalc = {
            lat: group1.reduce((sum, p) => sum + p.position.lat, 0) / group1.length,
            lng: group1.reduce((sum, p) => sum + p.position.lng, 0) / group1.length
        };
        const group2CenterCalc = {
            lat: group2.reduce((sum, p) => sum + p.position.lat, 0) / group2.length,
            lng: group2.reduce((sum, p) => sum + p.position.lng, 0) / group2.length
        };
        const distanceBetweenGroupsCalc = calculateDistanceBetweenPoints(group1CenterCalc, group2CenterCalc);
        
        // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ "‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡πâ‡∏ô‡πÅ‡∏£‡∏Å" ‡πÉ‡∏Å‡∏•‡πâ initialStartPoint ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞ snapThreshold
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏°‡∏µ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° (‡πÑ‡∏°‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
        const minGroupDistance = 1.0; // ‡∏•‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (‡πÄ‡∏°‡∏ï‡∏£) 
        const maxGroupDistance = 20.0; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î (‡πÄ‡∏°‡∏ï‡∏£) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏°‡∏≤‡∏Å
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const isSuitablePair = closestToStart.distance <= adjustedSnapThreshold && 
            distanceBetweenGroupsCalc >= minGroupDistance && 
            distanceBetweenGroupsCalc <= maxGroupDistance;
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const centerLineStart = {
            lat: (group1[0].position.lat + group2[0].position.lat) / 2,
            lng: (group1[0].position.lng + group2[0].position.lng) / 2
        };
        const centerLineEnd = {
            lat: (group1[group1.length - 1].position.lat + group2[group2.length - 1].position.lat) / 2,
            lng: (group1[group1.length - 1].position.lng + group2[group2.length - 1].position.lng) / 2
        };
        const closestPointOnCenterLine = findClosestPointOnLineSegment(initialStartPoint, centerLineStart, centerLineEnd);
        const distanceToCenterLine = calculateDistanceBetweenPoints(initialStartPoint, closestPointOnCenterLine);
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
        const isOptimalDistance = distanceBetweenGroupsCalc >= 2.0 && distanceBetweenGroupsCalc <= 15.0; // ‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏´‡πâ‡∏´‡∏•‡∏ß‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
        
        // ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
        const isBetterChoice = !bestAlignment || 
            distanceToCenterLine < (bestAlignment.firstPlantDistance * 0.7) || // ‡∏î‡∏µ‡∏Å‡∏ß‡πà‡∏≤ 30%
            (distanceToCenterLine <= bestAlignment.firstPlantDistance * 0.9 && isOptimalDistance); // ‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏•‡∏∞‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ô‡∏µ‡πâ
        const isCloseToCenterLine = distanceToCenterLine <= adjustedSnapThreshold * 0.8; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏õ‡πá‡∏ô 0.8 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏•‡∏ß‡∏°‡∏Ç‡∏∂‡πâ‡∏ô
        
        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const isGoodPair = isSuitablePair && isBetterChoice && isCloseToCenterLine;
        
        if (isGoodPair) {
          
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå - ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏ß‡πÄ‡∏ï‡πá‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ snap ‡πÑ‡∏î‡πâ
            let fullCenterLine: { start: Coordinate; end: Coordinate };
            
            if (direction === 'rows') {
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß: ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lng ‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
                const sorted1ByLng = [...group1].sort((a, b) => a.position.lng - b.position.lng);
                const sorted2ByLng = [...group2].sort((a, b) => a.position.lng - b.position.lng);
                
                const start1 = sorted1ByLng[0].position;
                const end1 = sorted1ByLng[sorted1ByLng.length - 1].position;
                const start2 = sorted2ByLng[0].position;
                const end2 = sorted2ByLng[sorted2ByLng.length - 1].position;
                
                // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß
                const centerStart = {
                    lat: (start1.lat + start2.lat) / 2,
                    lng: (start1.lng + start2.lng) / 2
                };
                const centerEnd = {
                    lat: (end1.lat + end2.lat) / 2,
                    lng: (end1.lng + end2.lng) / 2
                };
                
                fullCenterLine = { start: centerStart, end: centerEnd };
            } else {
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: ‡πÉ‡∏ä‡πâ lng coordinate ‡∏ó‡∏µ‡πà‡∏Ñ‡∏á‡∏ó‡∏µ‡πà ‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ï‡∏≤‡∏° lat
                const sorted1ByLat = [...group1].sort((a, b) => a.position.lat - b.position.lat);
                const sorted2ByLat = [...group2].sort((a, b) => a.position.lat - b.position.lat);
                
                const avgLng1 = group1.reduce((sum, p) => sum + p.position.lng, 0) / group1.length;
                const avgLng2 = group2.reduce((sum, p) => sum + p.position.lng, 0) / group2.length;
                const avgLng = (avgLng1 + avgLng2) / 2;
                
                // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
                const centerStart = {
                    lat: (sorted1ByLat[0].position.lat + sorted2ByLat[0].position.lat) / 2,
                    lng: avgLng
                };
                const centerEnd = {
                    lat: (sorted1ByLat[sorted1ByLat.length - 1].position.lat + sorted2ByLat[sorted2ByLat.length - 1].position.lat) / 2,
                    lng: avgLng
                };
                
                fullCenterLine = { start: centerStart, end: centerEnd };
            }
            
            bestAlignment = {
                type: groupType,
                row1: group1,
                row2: group2,
                firstPlantDistance: closestToStart.distance,
                firstPlant: closestToStart.plant,
                centerLine: fullCenterLine
            };
        }
    }

    if (!bestAlignment) {
        
        // üöÄ Fallback: ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡πà‡∏≠‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å initialStartPoint ‡πÑ‡∏õ rawEndPoint
        const allPlants = [...plants];
        const directPlants = allPlants.filter(plant => {
            const closestPoint = findClosestPointOnLineSegment(plant.position, initialStartPoint, rawEndPoint);
            const distance = calculateDistanceBetweenPoints(plant.position, closestPoint);
            
            return distance <= 15.0; // ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏ô 15 ‡πÄ‡∏°‡∏ï‡∏£
        });
        return { alignedEnd: rawEndPoint, selectedPlants: directPlants, snappedStart: initialStartPoint };
    }

    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì snappedStart: ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà projection ‡∏Ç‡∏≠‡∏á initialStartPoint ‡∏•‡∏á‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
    // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏Ñ‡∏ß‡∏£ snap ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    // ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ç‡∏¢‡∏±‡∏ö‡πÑ‡∏Å‡∏•‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°
    const projectedStart = findClosestPointOnLineSegment(initialStartPoint, bestAlignment.centerLine.start, bestAlignment.centerLine.end);
    const distanceToProjection = calculateDistanceBetweenPoints(initialStartPoint, projectedStart);
    
    // ‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÑ‡∏Å‡∏•‡∏Å‡∏ß‡πà‡∏≤ snapThreshold ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏à‡∏∏‡∏î‡πÄ‡∏î‡∏¥‡∏°
    const snappedStart = distanceToProjection <= snapThreshold ? projectedStart : initialStartPoint;
    
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô snap ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    const distanceToCenterLine = calculateDistanceBetweenPoints(initialStartPoint, snappedStart);

    // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
    // ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà rawEndPoint
    const alignedEnd = findClosestPointOnLineSegment(rawEndPoint, bestAlignment.centerLine.start, bestAlignment.centerLine.end);
    
    // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd
    const allPlantsInPair = [...bestAlignment.row1, ...bestAlignment.row2];
    
    const selectedPlants = allPlantsInPair.filter((plant, index) => {
        // ‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
        const plantProjected = findClosestPointOnLineSegment(plant.position, bestAlignment.centerLine.start, bestAlignment.centerLine.end);
        
        // üîß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏à‡∏£‡∏¥‡∏á‡πÜ ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡∏õ‡∏•‡∏≤‡∏¢
        const distanceToStart = calculateDistanceBetweenPoints(plantProjected, snappedStart);
        const distanceToEnd = calculateDistanceBetweenPoints(plantProjected, alignedEnd);
        const lateralLength = calculateDistanceBetweenPoints(snappedStart, alignedEnd);
        
        // üîß ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì tolerance ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡∏Ñ‡∏π‡πà‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå
        const calculatePlantSpacing = (plants: PlantLocation[]): number => {
            if (plants.length < 2) return 5.0; // ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
            let totalDistance = 0;
            let count = 0;
            for (let i = 0; i < plants.length - 1; i++) {
                const distance = calculateDistanceBetweenPoints(plants[i].position, plants[i + 1].position);
                totalDistance += distance;
                count++;
            }
            return totalDistance / count;
        };
        
        const row1Spacing = calculatePlantSpacing(bestAlignment.row1);
        const row2Spacing = calculatePlantSpacing(bestAlignment.row2);
        const avgPlantSpacing = (row1Spacing + row2Spacing) / 2;
        const pipeLengthTolerance = Math.max(2.0, avgPlantSpacing * 0.4); // ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 2 ‡πÄ‡∏°‡∏ï‡∏£ ‡∏´‡∏£‡∏∑‡∏≠ 40% ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ projected point ‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢ (‡∏õ‡∏£‡∏±‡∏ö tolerance ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ)
        const isWithinPipeLength = (distanceToStart + distanceToEnd) <= (lateralLength + pipeLengthTolerance);
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á snappedStart ‡πÅ‡∏•‡∏∞ alignedEnd ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô)
        let isInRange = false;
        
        if (bestAlignment.type === 'between_rows') {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° lng - ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
            const minLng = Math.min(snappedStart.lng, alignedEnd.lng);
            const maxLng = Math.max(snappedStart.lng, alignedEnd.lng);
            // ‡∏õ‡∏£‡∏±‡∏ö tolerance ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡∏ä‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏π‡∏Å‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏°‡∏≤‡∏Å‡∏à‡∏∞‡∏°‡∏µ tolerance ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            const lngTolerance = Math.max(0.000005, avgPlantSpacing * 0.00001); // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 0.5 ‡πÄ‡∏°‡∏ï‡∏£
            isInRange = plantProjected.lng >= minLng + lngTolerance && plantProjected.lng <= maxLng - lngTolerance;
            
        } else {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏° lat - ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
            const minLat = Math.min(snappedStart.lat, alignedEnd.lat);
            const maxLat = Math.max(snappedStart.lat, alignedEnd.lat);
            // ‡∏õ‡∏£‡∏±‡∏ö tolerance ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ - ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡∏ä‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏π‡∏Å‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏°‡∏≤‡∏Å‡∏à‡∏∞‡∏°‡∏µ tolerance ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
            const latTolerance = Math.max(0.000005, avgPlantSpacing * 0.00001); // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ 0.5 ‡πÄ‡∏°‡∏ï‡∏£
            isInRange = plantProjected.lat >= minLat + latTolerance && plantProjected.lat <= maxLat - latTolerance;
        }
        
        // üîß ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏à‡∏£‡∏¥‡∏á‡πÜ
        let isBetweenPlantPairs = false;
        if (bestAlignment.type === 'between_rows') {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö between_rows: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á lat ‡∏Ç‡∏≠‡∏á‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 1 ‡πÅ‡∏•‡∏∞‡πÅ‡∏ñ‡∏ß‡∏ó‡∏µ‡πà 2
            const row1LatAvg = bestAlignment.row1.reduce((sum, p) => sum + p.position.lat, 0) / bestAlignment.row1.length;
            const row2LatAvg = bestAlignment.row2.reduce((sum, p) => sum + p.position.lat, 0) / bestAlignment.row2.length;
            const minRowLat = Math.min(row1LatAvg, row2LatAvg);
            const maxRowLat = Math.max(row1LatAvg, row2LatAvg);
            isBetweenPlantPairs = plant.position.lat >= minRowLat && plant.position.lat <= maxRowLat;
        } else {
            // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö between_cols: ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á lng ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 1 ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà 2
            const col1LngAvg = bestAlignment.row1.reduce((sum, p) => sum + p.position.lng, 0) / bestAlignment.row1.length;
            const col2LngAvg = bestAlignment.row2.reduce((sum, p) => sum + p.position.lng, 0) / bestAlignment.row2.length;
            const minColLng = Math.min(col1LngAvg, col2LngAvg);
            const maxColLng = Math.max(col1LngAvg, col2LngAvg);
            isBetweenPlantPairs = plant.position.lng >= minColLng && plant.position.lng <= maxColLng;
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ (‡∏õ‡∏£‡∏±‡∏ö tolerance ‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ)
        const distanceToLine = calculateDistanceBetweenPoints(plant.position, plantProjected);
        const distanceTolerance = Math.max(1.5, avgPlantSpacing * 0.3); // ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1.5 ‡πÄ‡∏°‡∏ï‡∏£ ‡∏´‡∏£‡∏∑‡∏≠ 30% ‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        const result = isInRange && isWithinPipeLength && distanceToLine <= distanceTolerance && isBetweenPlantPairs;
        
        return result;
    });

    // üöÄ Fallback mechanism: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á ‡πÉ‡∏´‡πâ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
    if (selectedPlants.length === 0 && allPlantsInPair.length > 0) {
        
        // ‡∏´‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢ (‡∏•‡∏î‡∏à‡∏≤‡∏Å 15 ‡πÄ‡∏õ‡πá‡∏ô 8 ‡πÄ‡∏°‡∏ï‡∏£)
        const fallbackPlants = allPlantsInPair.filter(plant => {
            const lateralStart = snappedStart;
            const lateralEnd = alignedEnd;
            const closestPoint = findClosestPointOnLineSegment(plant.position, lateralStart, lateralEnd);
            const distance = calculateDistanceBetweenPoints(plant.position, closestPoint);
            
            // ‡∏õ‡∏£‡∏±‡∏ö fallback tolerance ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏•‡∏π‡∏Å‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô
            return distance <= 5.0; // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 5 ‡πÄ‡∏°‡∏ï‡∏£ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏û‡∏∑‡∏ä‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏π‡∏Å‡∏´‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡∏°‡∏≤‡∏Å
        });
        
        if (fallbackPlants.length > 0) {
            return { alignedEnd, selectedPlants: fallbackPlants, snappedStart };
        }
    }

    return { alignedEnd, selectedPlants, snappedStart };
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡πâ‡∏≥‡∏£‡∏ß‡∏°
export const calculateTotalWaterNeed = (plants: PlantLocation[]): number => {
    return plants.reduce((total, plant) => total + plant.plantData.waterNeed, 0);
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á ID ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢
export const generateLateralPipeId = (): string => {
    return `lateral_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏¢‡πà‡∏≠‡∏¢ (Emitter Lines)
// üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£: ‡∏™‡∏£‡πâ‡∏≤‡∏á emitterLines ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏´‡∏°‡∏î 'between_plants' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
export const generateEmitterLines = (
    lateralPipeId: string,
    lateralStart: Coordinate,
    lateralEnd: Coordinate,
    plants: PlantLocation[],
    emitterDiameter: number = 4,
    placementMode?: 'over_plants' | 'between_plants'
): any[] => {
    // ‚ö†Ô∏è ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÇ‡∏´‡∏°‡∏î 'between_plants' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
    // ‡πÇ‡∏´‡∏°‡∏î 'over_plants' ‡∏ó‡πà‡∏≠‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ö‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡πÅ‡∏¢‡∏Å
    if (placementMode !== 'between_plants') {
        return []; // ‡πÑ‡∏°‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á emitterLines ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏≠‡∏∑‡πà‡∏ô
    }
    
    const emitterLines: any[] = [];
    
    // ‡∏™‡∏£‡πâ‡∏≤‡∏á emitterLines ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÉ‡∏ô‡πÇ‡∏´‡∏°‡∏î between_plants
    plants.forEach((plant, index) => {
        // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        const closestPointOnLateral = findClosestPointOnLineSegment(
            plant.position,
            lateralStart,
            lateralEnd
        );

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏¢‡πà‡∏≠‡∏¢‡∏Ç‡∏ô‡∏≤‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏à‡∏≤‡∏Å lateral pipe ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        const distance = calculateDistanceBetweenPoints(closestPointOnLateral, plant.position);

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢ (‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 20 ‡πÄ‡∏°‡∏ï‡∏£)
        if (distance <= 20) {
            const emitterLine = {
                id: `emitter_${lateralPipeId}_${index}`,
                lateralPipeId: lateralPipeId,
                plantId: plant.id,
                coordinates: [closestPointOnLateral, plant.position],
                length: distance,
                diameter: emitterDiameter,
                emitterType: 'drip'
            };
            
            emitterLines.push(emitterLine);
        }
    });

    return emitterLines;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏Ç‡∏ô‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏´‡∏°‡∏î‡∏ß‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
// **‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏¢‡πà‡∏≠‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏•‡∏≤‡∏Å‡∏ñ‡∏∂‡∏á‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô**
export const generateEmitterLinesForBetweenPlantsMode = (
    lateralPipeId: string,
    lateralStart: Coordinate,
    lateralEnd: Coordinate,
    selectedPlants: PlantLocation[], // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å plants ‡πÄ‡∏õ‡πá‡∏ô selectedPlants
    emitterDiameter: number = 4
): any[] => {
    
    
    // üîß ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ó‡πà‡∏≠‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö threshold ‡∏ï‡∏≤‡∏°‡∏ô‡∏±‡πâ‡∏ô
    const latDiff = Math.abs(lateralEnd.lat - lateralStart.lat);
    const lngDiff = Math.abs(lateralEnd.lng - lateralStart.lng);
    const isVerticalPipe = latDiff > lngDiff; // ‡∏ó‡πà‡∏≠‡πÉ‡∏ô‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á‡∏ñ‡πâ‡∏≤ lat ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡∏Å‡∏Å‡∏ß‡πà‡∏≤ lng
    
    const emitterLines: any[] = [];

    selectedPlants.forEach(plant => {
        // üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏à‡∏∏‡∏î‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
        const closestPointOnLateral = findClosestPointOnLineSegment(
            plant.position,
            lateralStart,
            lateralEnd
        );

        const distance = calculateDistanceBetweenPoints(closestPointOnLateral, plant.position);
        
        // üîß ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö threshold
        const calculatePlantSpacing = (): number => {
            if (selectedPlants.length < 2) return 5.0;
            let totalDistance = 0;
            let count = 0;
            for (let i = 0; i < selectedPlants.length - 1; i++) {
                const dist = calculateDistanceBetweenPoints(selectedPlants[i].position, selectedPlants[i + 1].position);
                totalDistance += dist;
                count++;
            }
            return totalDistance / count;
        };
        
        const avgSpacing = calculatePlantSpacing();
        const adaptiveMaxDistance = Math.max(8.0, avgSpacing * 0.8); // ‡πÄ‡∏û‡∏¥‡πà‡∏° threshold ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏¢‡πà‡∏≠‡∏¢‡∏î‡πâ‡∏ß‡∏¢ threshold ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
        if (distance <= adaptiveMaxDistance) {
            // üîß ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á coordinates ‡πÉ‡∏´‡πâ‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡∏Ç‡∏∂‡πâ‡∏ô
            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏£‡∏á‡∏à‡∏≤‡∏Å closest point ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÇ‡∏î‡∏¢‡∏ï‡∏£‡∏á
            const emitterLine = {
                id: `emitter_${lateralPipeId}_${plant.id}`,
                lateralPipeId: lateralPipeId,
                plantId: plant.id,
                coordinates: [
                    { lat: closestPointOnLateral.lat, lng: closestPointOnLateral.lng }, // ‡∏à‡∏∏‡∏î‡∏ö‡∏ô‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢
                    { lat: plant.position.lat, lng: plant.position.lng } // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ
                ],
                length: distance,
                diameter: emitterDiameter,
                emitterType: 'drip',
                isVisible: true,
                isActive: true,
                connectionPoint: { lat: closestPointOnLateral.lat, lng: closestPointOnLateral.lng }
            };

            emitterLines.push(emitterLine);
            

        } else {
            console.log(`‚ùå Skipped plant ${plant.id}: distance ${distance.toFixed(2)}m > max ${adaptiveMaxDistance.toFixed(1)}m`);
        }
    });

    return emitterLines;
};

// üöÄ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á emitter lines ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multi-segment lateral pipes
export const generateEmitterLinesForMultiSegment = (
    lateralPipeId: string,
    lateralCoordinates: Coordinate[], // ‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå (‡∏£‡∏ß‡∏° waypoints)
    selectedPlants: PlantLocation[],
    emitterDiameter: number = 4
): any[] => {
    const emitterLines: any[] = [];

    selectedPlants.forEach(plant => {
        // ‡∏´‡∏≤‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ö‡∏ô‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (multi-segment)
        let closestPoint: Coordinate | null = null;
        let minDistance = Infinity;

        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏ó‡πà‡∏≠‡∏¢‡πà‡∏≠‡∏¢
        for (let i = 0; i < lateralCoordinates.length - 1; i++) {
            const segmentStart = lateralCoordinates[i];
            const segmentEnd = lateralCoordinates[i + 1];
            
            const closestOnSegment = findClosestPointOnLineSegment(
                plant.position,
                segmentStart,
                segmentEnd
            );
            
            const distance = calculateDistanceBetweenPoints(closestOnSegment, plant.position);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = closestOnSegment;
            }
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡πà‡∏≠‡πÅ‡∏¢‡∏Å‡∏¢‡πà‡∏≠‡∏¢‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        if (closestPoint && minDistance <= 10.0) {
            const emitterLine = {
                id: `emitter_${lateralPipeId}_${plant.id}`,
                lateralPipeId: lateralPipeId,
                plantId: plant.id,
                coordinates: [closestPoint, plant.position],
                length: minDistance,
                diameter: emitterDiameter,
                emitterType: 'drip',
                isVisible: true,
                isActive: true,
                connectionPoint: closestPoint
            };

            emitterLines.push(emitterLine);
        }
    });

    return emitterLines;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏£‡∏ß‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å segment ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏≤‡∏î‡πÅ‡∏ö‡∏ö multi-segment - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
export const accumulatePlantsFromAllSegments = (
    allWaypoints: Coordinate[], // ‡∏£‡∏ß‡∏° startPoint, waypoints, currentPoint
    plants: PlantLocation[],
    placementMode: 'over_plants' | 'between_plants',
    snapThreshold: number = 20
): PlantLocation[] => {
    if (!allWaypoints || allWaypoints.length < 2) {
        return [];
    }
    
    // ‡πÉ‡∏ä‡πâ computeMultiSegmentAlignment ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡πÄ‡∏≠‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
    const startPoint = allWaypoints[0];
    const waypoints = allWaypoints.slice(1, -1); // waypoints ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏≤‡∏á
    const currentPoint = allWaypoints[allWaypoints.length - 1];
    
    const result = computeMultiSegmentAlignment(
        startPoint,
        waypoints,
        currentPoint,
        plants,
        placementMode,
        snapThreshold
    );
    
    return result.allSelectedPlants;
};

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì multi-segment alignment - ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
export const computeMultiSegmentAlignment = (
    startPoint: Coordinate,
    waypoints: Coordinate[],
    currentPoint: Coordinate,
    plants: PlantLocation[],
    placementMode: 'over_plants' | 'between_plants',
    snapThreshold: number = 20
): {
    allSelectedPlants: PlantLocation[];
    totalWaterNeed: number;
    alignedEndPoint: Coordinate;
    segmentResults: Array<{
        startPoint: Coordinate;
        endPoint: Coordinate;
        selectedPlants: PlantLocation[];
        alignedEnd: Coordinate;
    }>;
} => {
    const allWaypoints = [startPoint, ...waypoints, currentPoint];
    const segmentResults: Array<{
        startPoint: Coordinate;
        endPoint: Coordinate;
        selectedPlants: PlantLocation[];
        alignedEnd: Coordinate;
    }> = [];
    
    let lastAlignedEnd = startPoint;
    const allSelectedPlants: PlantLocation[] = [];
    const processedPlantIds = new Set<string>();
    const waypointProximityThreshold = snapThreshold * 1.5; // ‡πÉ‡∏ä‡πâ threshold ‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏Å‡∏ß‡πà‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
    
    // üéØ Segment layout explanation:
    // segment 0: startPoint ‚Üí waypoint[0]   (i=0) ‚Üê ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏£‡∏á waypoint[0] ‡∏ô‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    // segment 1: waypoint[0] ‚Üí waypoint[1]  (i=1) ‚Üê ‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ï‡∏£‡∏á waypoint[1] ‡∏ô‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
    // segment 2: waypoint[1] ‚Üí currentPoint (i=2) ‚Üê ‡πÑ‡∏°‡πà‡∏°‡∏µ waypoint ‡∏ï‡∏£‡∏á‡∏õ‡∏•‡∏≤‡∏¢
    
    // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏µ‡∏•‡∏∞ segment
    for (let i = 0; i < allWaypoints.length - 1; i++) {
        const segmentStart = i === 0 ? startPoint : lastAlignedEnd;
        const segmentEnd = allWaypoints[i + 1];
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Å‡∏≤‡∏£ align ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö segment ‡∏ô‡∏µ‡πâ
        const segmentResult = computeAlignedLateral(
            segmentStart,
            segmentEnd,
            plants,
            placementMode,
            snapThreshold
        );
        
        // üö´ ‡∏Å‡∏£‡∏≠‡∏á‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ waypoint ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
        const filteredSegmentPlants: PlantLocation[] = [];
        
        segmentResult.selectedPlants.forEach(plant => {
            let shouldAddPlant = true;
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ waypoint ‡πÉ‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            for (let j = 0; j < waypoints.length; j++) {
                const waypoint = waypoints[j];
                const distanceToWaypoint = calculateDistanceBetweenPoints(plant.position, waypoint);
                
                // ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏Å‡∏•‡πâ waypoint
                if (distanceToWaypoint <= waypointProximityThreshold) {
                    // üéØ ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á segment ‡∏ó‡∏µ‡πà‡∏à‡∏ö‡∏ó‡∏µ‡πà waypoint ‡∏ô‡∏±‡πâ‡∏ô (‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß)
                    // segment i ‡∏à‡∏ö‡∏ó‡∏µ‡πà waypoint j ‡πÄ‡∏°‡∏∑‡πà‡∏≠ i === j
                    if (i !== j) {
                        // segment ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà segment ‡∏ó‡∏µ‡πà‡∏à‡∏ö‡∏ó‡∏µ‡πà waypoint ‡∏ô‡∏µ‡πâ ‡∏à‡∏∂‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡∏ô‡∏µ‡πâ
                        // console.log(`üö´ Plant ${plant.id} near waypoint[${j}] excluded from segment ${i} (should be in segment ${j})`);
                        shouldAddPlant = false;
                        break;
                    } else {
                        // console.log(`‚úÖ Plant ${plant.id} near waypoint[${j}] included in segment ${i} (before turn)`);
                    }
                }
            }
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥‡πÅ‡∏•‡∏∞‡πÑ‡∏°‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà overlap
            if (shouldAddPlant && !processedPlantIds.has(plant.id)) {
                filteredSegmentPlants.push(plant);
                allSelectedPlants.push(plant);
                processedPlantIds.add(plant.id);
            }
        });
        
        // ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Ç‡∏≠‡∏á segment (‡πÉ‡∏ä‡πâ plants ‡∏ó‡∏µ‡πà‡∏Å‡∏£‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß)
        segmentResults.push({
            startPoint: segmentStart,
            endPoint: segmentEnd,
            selectedPlants: filteredSegmentPlants,
            alignedEnd: segmentResult.alignedEnd
        });
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó aligned end ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö segment ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
        lastAlignedEnd = segmentResult.alignedEnd;
    }
    
    const totalWaterNeed = calculateTotalWaterNeed(allSelectedPlants);
    
    return {
        allSelectedPlants,
        totalWaterNeed,
        alignedEndPoint: lastAlignedEnd,
        segmentResults
    };
};

// Export ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å
// Note: findPlantsInBetweenPlantsMode and findPlantsInOverPlantsMode are now exported directly

// ‡πÇ‡∏´‡∏°‡∏î A: ‡∏ß‡∏≤‡∏á‡∏ó‡∏±‡∏ö‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á)
const computeOverPlantsModeFromMainPipe = (
    snappedStartPoint: Coordinate,
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number,
    direction: 'rows' | 'columns'
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {
    return computeOverPlantsMode(snappedStartPoint, rawEndPoint, plants, snapThreshold, direction);
};

// ‡πÇ‡∏´‡∏°‡∏î B: ‡∏ß‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡πÅ‡∏ô‡∏ß‡∏ï‡πâ‡∏ô‡πÑ‡∏°‡πâ (‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å‡∏ó‡πà‡∏≠‡πÄ‡∏°‡∏ô‡∏£‡∏≠‡∏á)
const computeBetweenPlantsModeFromMainPipe = (
    snappedStartPoint: Coordinate,
    rawEndPoint: Coordinate,
    plants: PlantLocation[],
    snapThreshold: number,
    direction: 'rows' | 'columns'
): { alignedEnd: Coordinate; selectedPlants: PlantLocation[]; snappedStart: Coordinate } => {
    return computeBetweenPlantsMode(snappedStartPoint, rawEndPoint, plants, snapThreshold, direction);
};
